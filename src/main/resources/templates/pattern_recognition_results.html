<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8" />
    <title th:text="${'TPR Results for task: ' + token + '| Metaprot'}"></title>
    <link rel="stylesheet" type="text/css" href="/css/lib/bootstrap.simplex.min.css" />
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Arimo" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="/css/site.css" />
</head>
<style>
    .axis {
        shape-rendering: crispEdges;
    }

    .x.axis line {
        stroke: #000;
    }

    .x.axis .minor {
        stroke-opacity: .5;
    }

    .y.axis line,
    .y.axis path {
        stroke: #000;
    }
</style>
<body>
    <div th:include="fragments/header :: header"></div>

    <div class="container">
        <div class="row">
            <div class="panel panel-default">
                <div class="panel-heading" th:text="'Pattern Recognition Results for task: ' + ${token}"></div>
                <div class="panel-body">
                    <div class="row">
                        <div class="col-sm-7">
                            <div class="plot">
                                <svg id="visualisation"></svg>  <!-- rendered in JS -->
                            </div>
                            <div class="well well-lg">
                                <h4>Tools</h4>
                                <div class="form-group">
                                    <button class="btn btn-default" id="exportCsvBtn">Export results as CSV</button>
                                    <span class="invisible" id="exportCsvLink"><a download="metaprot_pattern_recog.csv"></a></span>
                                </div>
                                <div class="form-group">
                                    <button class="btn btn-default" id="exportPlotBtn">Export plot as SVG</button>
                                    <span class="invisible" id="exportPlotLink"><a download="metaprot_pattern_recog_plot.svg"></a></span>
                                </div>
                            </div>
                        </div>
                        <div class="col-sm-5">
                            <div class="well well-lg">
                                <h4>Clusters</h4>
                                <form id="cluster-selection-form" class="form-horizontal">
                                    <div class="form-group">
                                        <label for="input-num-clusters" class="control-label">Number of clusters:</label>
                                        <input type="text" th:value="${numClusters}" id="input-num-clusters" class="form-control" />
                                    </div>
                                    <div class="form-group">
                                        <label for="input-mem-per-cluster" class="control-label">Minimum members per cluster:</label>
                                        <input type="text" th:value="${minMembersPerCluster}" id="input-mem-per-cluster" class="form-control" />
                                    </div>
                                    <div class="form-group">
                                        <input class="btn btn-default" type="submit" value="Submit" />
                                    </div>
                                    <div class="form-group">
                                        <label for="cluster-select" class="control-label">Select a cluster:</label>
                                        <select id="cluster-select" class="form-control">
                                            <option th:each="result, i : ${results}" th:text="${i.count}" th:value="${i.count - 1}"></option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label for="cluster-checkbox">Select all</label>
                                        <input type="checkbox" id="cluster-checkbox" />
                                    </div>
                                </form>
                            </div>
                            <div id="sidePanel" class="pattern-recognition"></div> <!-- rendered by SidePanel module -->
                        </div>
                    </div>

                    <hr />

                    <div class="row">
                        <h3>Strain visualization</h3>
                        <div class="col-sm-7">
                            <div class="plot">
                                <svg id="strain-plot-1"></svg>  <!-- rendered in JS -->
                            </div>
                            <div class="plot">
                                <svg id="strain-plot-2"></svg>  <!-- rendered in JS -->
                            </div>
                            <div class="plot">
                                <svg id="strain-plot-3"></svg>  <!-- rendered in JS -->
                            </div>
                        </div>
                        <div class="col-sm-5">
                            <div class="well well-lg">
                                <h4>Metabolites</h4>
                            </div>
                            <div id="metabolite-table-container"></div>
                        </div>
                    </div>

                </div>
                <div class="panel-footer">footer</div>
            </div>
        </div>
    </div>

    <div th:include="fragments/footer :: footer"></div>

    <script type="text/javascript" src="/js/lib/jquery-3.1.0.min.js"></script>
    <script type="text/javascript" src="/js/lib/bootstrap.min.js"></script>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="/js/PatternRecogPlot.js"></script>
    <script type="text/javascript">

        // sanitizes the input string for safe use as classNames, ids, etc.
        // update as needed
        // replaces: . " " , ; : with "-"
        function sanitizeForHtml(input) {
            input = input.trim();
            return input.replace(/\./g, "-")
                    .replace(/\s/g, "-")
                    .replace(/[:;,#.)(]/g, "-");
        }

        /*<![CDATA[*/
        /**
         * Module for rendering SidePanel tables for pattern recognition analysis.
         *
         * @param data the input dataset in form : [ [ {metaboliteName:"", dataPoints:[ {'abundanceRatio':__, 'timePoint':__} ]}, ... ] ]
         * @param $sideTableContainer the containing JQ element that holds side tables (direct parent)
         * @type {Function}/Module
         */
        var SidePanel = (function(dataset, $sideTableContainer) {

            /**
             * Renders the side tables with the input data
             */
            var drawSideTables = function() {

                if ( !dataset || !(dataset.length > 0) || !(dataset[0].length > 0)) {
                    console.log("No data to draw sidetable.");
                    return;
                }

                // get the headings for the table by iterating through one of the dataPoints
                var headings = [];
                for (var i = 0; i < dataset[0][0]['dataPoints'].length; i++) {
                    headings.push(dataset[0][0]['dataPoints'][i].timePoint);
                }

                var tableWrapper = document.createElement("div");   // will hold all tables

                // for each cluster
                for (var i = 0; i < dataset.length; i++) {

                    // create a table for this cluster
                    var table = document.createElement("table");
                    table.classList.add("table", "table-hover");
                    table.setAttribute("data-cluster-id", i);
                    table.style.display = "none";

                    var tableHead = document.createElement("thead");
                    var tableBody = document.createElement("tbody");

                    // populate thead with headings
                    var tableRow = document.createElement("tr");
                    var thName = document.createElement("th");
                    thName.innerHTML = "Name";

                    tableRow.appendChild(thName);

                    // create rest of the headings
                    for (var j = 0; j < headings.length; j++) {
                        var thCurrent = document.createElement("th");
                        thCurrent.innerHTML = headings[j];

                        tableRow.appendChild(thCurrent);
                    }

                    // append the row of headings to thead
                    tableHead.appendChild(tableRow);

                    // for each metabolite in cluster
                    for (var j = 0; j < dataset[i].length; j++) {

                        // create a new row; append a td element with the metabolite name
                        var rowCurr = document.createElement("tr");
                        rowCurr.setAttribute("data-cluster-position", j);
                        rowCurr.classList.add(sanitizeForHtml(dataset[i][j]['metaboliteName']), "data-row");

                        var tDataName = document.createElement("td");
                        tDataName.innerHTML = dataset[i][j]['metaboliteName'];

                        rowCurr.appendChild(tDataName);

                        // for each temporal datapoint of this metabolite
                        for (var k = 0; k < dataset[i][j]['dataPoints'].length; k++) {
                            var tData = document.createElement("td");
                            tData.innerHTML = dataset[i][j]['dataPoints'][k]['abundanceRatio'].toFixed(3);

                            rowCurr.appendChild(tData);
                        }

                        tableBody.appendChild(rowCurr);
                    }

                    // add table to wrapper
                    table.appendChild(tableHead);
                    table.appendChild(tableBody);
                    tableWrapper.appendChild(table);
                }

                // finally, add all tables to the sideTableContainer
                $sideTableContainer[0].appendChild(tableWrapper);

            };

            /**
             * Clears all entries in side table, leaving the container in pristine state.
             */
            var clearSideTables = function() {
                $sideTableContainer.empty();
            };

            /**
             * Updates the internal dataset used by the SidePanel instance.
             */
            var updateDataSet = function(data) {
                dataset = data;
            };

            /**
             * Given a cluster id, displays the table for that cluster (while hiding
             * all other tables).
             *
             * @param clusterId the numeric, zero-based cluster id
             */
            var displayTable = function(clusterId) {
                $("#" + $sideTableContainer.attr("id") + " table").css("display", "none");
                $('table[data-cluster-id="' + clusterId +'"]').css("display", "block");
            };

            /**
             * Returns a string of comma separated values in form:
             *
             * cluster <#>\n
             * x,x,x,x,x,x,... \n
             * ...
             * cluster <#>\n
             * y,y,y,y,y,y,... \n
             *
             * @return a comma separated, with newline delimited rows, string. Note
             * that no prefix is prepended to allow the user to modify the usage accordingly.
             */
            var exportDataAsCSV = function() {
                if ( !dataset || !(dataset.length > 0) || !(dataset[0].length > 0)) {
                    console.log("Cannot export null dataset.");
                    return;
                }

                // the string to return
                var csvString = "";

                // headings
                var heading = "name";
                for (var i = 0; i < dataset[0][0]['dataPoints'].length; i++) {
                    heading += ("," + dataset[0][0]['dataPoints'][i].timePoint);
                }
                csvString += (heading + "\n");

                // content, for each cluster
                for (var i = 0; i < dataset.length; i++) {

                    // add the cluster header, 1-based
                    csvString += ("cluster " + (i+1) + "\n");

                    // add the cluster data points, in form "name,time1Ratio,time2Ratio,time3Ratio,..."
                    // for each metabolite in cluster
                    for ( var j = 0; j < dataset[i].length; j++) {
                        var row = dataset[i][j].metaboliteName;

                        // for each timepoint for metabolite
                        for (var k = 0; k < dataset[i][j].dataPoints.length; k++) {
                            row += ("," + dataset[i][j].dataPoints[k].abundanceRatio);
                        }
                        row += "\n";
                        csvString += row;
                    }
                }

                return csvString;
            };

            return {
                drawSideTables : drawSideTables,
                displayTable : displayTable,
                clearSideTables : clearSideTables,
                updateDataSet : updateDataSet,
                exportDataAsCSV : exportDataAsCSV
            };
        });

        /*]]>*/ /* because of XML parsing */
    </script>
    <script th:inline="javascript" type="text/javascript">
        $(function() {

            // results of the task
            var results = [[${results}]];

            //Initialize plot
            var plot = new PatternRecogPlot(results);
            plot.InitChart("visualisation");

            // draw the regression line
            plot.drawRegressionLine([[${regressionLine}]])

            // render side panels using results, and bind necessary events
            var sidePanel = new SidePanel(results, $('#sidePanel'));
            sidePanel.drawSideTables();
            sidePanel.displayTable(0);

            // index for checkbox logic - keeps track of checkbox state for each cluster
            /*<![CDATA[*/
            var checkboxStatus = {};
            function resetCheckBoxStatus() {
                for (var i = 0; i < results.length; i++) {
                    checkboxStatus[i] = 0;                      // 0 = unchecked, 1 = checked
                }

                document.getElementById("cluster-checkbox").checked = false;
            }
            resetCheckBoxStatus();
            /*]]>*/ /* because of XML parsing */

            $('#cluster-select').on("change", function() {
                sidePanel.displayTable(+$(this).val());
                $('#cluster-checkbox').prop("checked", checkboxStatus[+$(this).val()]);
            });

            function bindSideTableEvents() {
                $('#sidePanel table tr').on("click", function() {
                    $(this).toggleClass("active");

                    var clusterId = +$(this).parents('table').attr('data-cluster-id');
                    var input = {};

                    input.i = clusterId;
                    input.j = +$(this).attr('data-cluster-position');
                    input.update = $(this).hasClass("active");

                    // update the plot
                    plot.updateChart([input]);
                });
            }
            bindSideTableEvents();

            $('#cluster-checkbox').on("change", function(e) {

                // get the cluster Id of the currently active cluster and the associated rows
                var activeClusterId = +$('#cluster-select').val();
                var $clusterRows = $('table[data-cluster-id="'+ activeClusterId + '"] tr.data-row');

                // array of updates to pass into drawing function
                var elementsToChange = [];
                var update = null;
                var addToArray = function() {
                    var obj = {};
                    obj.i = activeClusterId;
                    obj.j = +$(this).attr('data-cluster-position');
                    obj.update = update;

                    elementsToChange.push(obj);
                };

                // check if checkbox is checked
                if (e.target.checked) {
                    update = true;  // means to draw the lines
                    $clusterRows.each(addToArray);
                    $clusterRows.addClass("active");
                    checkboxStatus[activeClusterId] = 1;
                } else {
                    update = false; // means to remove lines
                    $clusterRows.each(addToArray);
                    $clusterRows.removeClass("active");
                    checkboxStatus[activeClusterId] = 0;
                }

                // draw selected elements
                plot.updateChart(elementsToChange);
            });


            // misc

            // redraws necessary components, say, on cluster number change
            // data is in the same format as the results variable above
            function redrawUI(data, regressionLine) {

                // for side panel
                sidePanel.clearSideTables();
                sidePanel.updateDataSet(data);
                sidePanel.drawSideTables();
                sidePanel.displayTable(0);
                bindSideTableEvents();

                /*<![CDATA[*/
                // for cluster select dropdown, redraw the options
                var $clusterSelect = $('#cluster-select');
                $clusterSelect.empty();
                for (var i = 0; i < data.length; i++) {
                    var option = document.createElement("option");
                    option.value = i;
                    option.innerText = i+1;
                    $clusterSelect[0].appendChild(option);
                }
                /*]]>*/ /* because of XML parsing */

                // remove any drawn .d3-paths and nodes
                $('.plot .d3-path, .plot .d3-node').remove();
                plot.updateDataSet(data);

                // reset state of checkbox
                resetCheckBoxStatus();

                // redraw regressionLine
                if (regressionLine) {
                    plot.drawRegressionLine(regressionLine);
                }
            }
            $('#cluster-selection-form').on("submit", function(e) {
                e.preventDefault();
                var self = this;

                // make an ajax call
                $.ajax({
                    url: "/analyze/pattern/re-analyze/" + [[${token}]],
                    method: "GET",
                    data: {
                        "numClusters": $('#input-num-clusters').val(),
                        "minMembersPerCluster": $('#input-mem-per-cluster').val()
                    },
                    success:function(data) {
                        console.log(data)

                        // update results variable and redraw necessary UI components
                        results = data.results;
                        redrawUI(data.results, data.regressionLine);
                    },
                    error:function(jqXHR, textStatus, errorThrown) {
                        console.log(jqXHR)
                        console.log(textStatus)
                        console.log(errorThrown)

                        var alertEle = document.getElementById("cluster-form-alert");
                        if (alertEle) {
                            alertEle.innerText = jqXHR.responseJSON.message;
                        } else {
                            var alert = document.createElement("div");
                            alert.innerText = jqXHR.responseJSON.message;
                            alert.classList.add("alert", "alert-danger");
                            alert.id = "cluster-form-select";

                            $(self).parent()[0].appendChild(alert);
                        }
                    }
                });
            });

            // export current side tables as a CSV
            function getUriForCsvDownload() {
                var csvString = "data:text/csv;charset=utf-8,";
                csvString += sidePanel.exportDataAsCSV();

                var encodedUri = encodeURI(csvString);
                return encodedUri;
            }
            $('#exportCsvBtn').on("click", function() {
                var $link = $('#exportCsvLink a');
                $link.attr("href", getUriForCsvDownload()).text("Download");
                $link[0].click();   // start download
            });

            $('#exportPlotBtn').on("click", function() {
                var $link = $('#exportPlotLink a');
                $link.attr("href", plot.getDataUrl());
                $link[0].click();
            });









            /*<![CDATA[*/

            /**
             *  Renders the demo sidepanel of metabolite names.
             *
             **/
            var demo;
            var strainIndex = {};               // { strainName:patternRecogPlotInstance, ... }
            (demo = function(data) {
                var metaboliteIndex = {};       // { generalMetaboliteName:[metadata1, ...] }

                // define HTML elements
                var table = document.createElement("table");
                table.classList.add("table", "table-hover");
                table.id = "metabolite-table";

                var thead = document.createElement("thead");
                var theadRow = document.createElement("tr");
                var theadRowData = document.createElement("td");
                theadRowData.innerText = "Name";
                theadRow.appendChild(theadRowData);
                thead.appendChild(theadRow);

                table.appendChild(thead);

                var tbody = document.createElement("tbody");

                // for all data points, add them to respective indexes
                for (var i = 0; i < data.length; i++) {
                    for (var j = 0; j < data[i].length; j++) {
                        var nameArr = data[i][j].metaboliteName.split("_");    // last ele=replica_counter, 2nd to last ele=strainName
                        var strainName = nameArr[nameArr.length - 2];

                        // add to index
                        if (!strainIndex[strainName]) {
                            strainIndex[strainName] = 0;
                        }

                        var generalMetaboliteName = nameArr[0] + "_" + nameArr[1];

                        if (!metaboliteIndex[generalMetaboliteName]) {
                            metaboliteIndex[generalMetaboliteName] = [];
                        }

                        metaboliteIndex[generalMetaboliteName].push(strainName + "-" + i + "-" + j); // always strainName-#
                    }
                }

                // generate the table data elements
                for (var generalMetaboliteName in metaboliteIndex) {
                    var tdata = document.createElement("td");
                    tdata.innerText = generalMetaboliteName;
                    tdata.classList.add(sanitizeForHtml(generalMetaboliteName));
                    tdata.setAttribute("data-meta", metaboliteIndex[generalMetaboliteName]);

                    var trow = document.createElement("tr");
                    trow.classList.add("data-row")
                    trow.appendChild(tdata);
                    tbody.appendChild(trow);
                }

                table.appendChild(tbody);
                document.getElementById("metabolite-table-container").appendChild(table);

                // bind click event
                $('#metabolite-table tbody td').on("click", function() {
                    var meta = $(this).attr("data-meta").split(",");

                    // get update status (whether to delete or draw)
                    var $parent = $(this).parent()
                    $parent.toggleClass("active");
                    var update = $parent.hasClass("active");

                    // for each strain-i-j, generate list of updates
                    var updates = {};
                    for (var index = 0; index < meta.length; index++) {
                        var strainIndexArr = meta[index].split("-");
                        var strainName = strainIndexArr[0];
                        var i = strainIndexArr[1];
                        var j = strainIndexArr[2];

                        if (!updates[strainName]) {
                            updates[strainName] = [];
                        }

                        updates[strainName].push({
                            "i": +i,
                            "j": +j,
                            "update": update
                        });
                    }
                    
                    // for each plot, make the updates
                    for (strainName in updates) {
                        strainIndex[strainName].updateChart(updates[strainName]);
                    }
                });

            } )(results);

            /*]]>*/ /* because of XML parsing */

            // TODO abineet
            var htmlBindings = ["strain-plot-1", "strain-plot-2", "strain-plot-3"];
            var counter = 0;
            for(var strainID in strainIndex) {
                if(strainIndex.hasOwnProperty(strainID)){
                    strainIndex[strainID] = new PatternRecogPlot(results);
                    strainIndex[strainID].InitChart(htmlBindings[counter]);
                    counter++;
                }
            }

        }); // end docready
    </script>
</body>

</html>